<!DOCTYPE html>
<html>
<head>
    <title>Maria - Quick Start for the Impatient</title>

    <link href="css/base.css" rel="stylesheet">

</head>
<body>

    <div class="wrapper">


        <h1>Quick Start for the Impatient</h1>

        <p>We have things to do. Let&rsquo;s use Maria to build an application called &ldquo;checkit&rdquo; to organize our to-dos.</p>

        <p><img src="img/checkit-ui.png" alt="checkit UI"></p>

        <p>By the end of this tutorial, you&rsquo;ll understand how the components of an application written in the MVC style with Maria communicate and be ready to create more complex client-side application on your own.</p>

        <p>Let&rsquo;s go...</p>


        <h2>Separate Their Code From Our Code</h2>

        <p>There are generic libraries out there in the world that are written, ready, and just waiting for us to download for use in our application. There is application-specific source code that we will write. Create a <code>checkit/</code> directory to contain the entire application with <code>lib/</code> and <code>src/</code> sub-directories to keep these two types of files separate.</p>

        <ul class="filetree">
            <li>
                checkit/
                <ul>
                    <li>lib/</li>
                    <li>src/</li>
                </ul>
            </li>
        </ul>


        <h2>Download Maria and Other Libraries</h2>

        <p>To give our application structure, we'll use the <a href="https://github.com/petermichaux/maria">Maria</a> framework. Download the latest version from the following link and save it as <code>checkit/lib/maria/maria.js</code>.</p>

        <p><a href="http://peter.michaux.ca/downloads/maria/rc2/maria.js">http://peter.michaux.ca/downloads/maria/rc2/maria.js</a></p>

        <p>In this application, we&rsquo;ll need to manipulate the <code>class</code> attribute values of DOM elements. We&rsquo;ll use the <a href="https://github.com/petermichaux/aristocrat">Aristocrat</a> library. Download the latest version from the following link and save it as <code>checkit/lib/aristocrat/aristocrat.js</code>.</p>

        <p><a href="http://peter.michaux.ca/downloads/aristocrat/1/aristocrat.js">http://peter.michaux.ca/downloads/aristocrat/1/aristocrat.js</a></p>


        <h2>Namespace Our Application Code</h2>

        <p>The conventions built into Maria expect our application classes are all properties of a single namespace object. Create a file <code>checkit/src/js/namespace.js</code> defining our namespace object.</p>

<pre><code>var checkit = {};</code></pre>


        <h2>Prepare for Our Own Utilities</h2>

        <p>It&rsquo;d be great if every miscellaneous utility function we need in our application was available in a third-party library; however, that is rarely the case in any application. Create a <code>checkit/src/js/util.js</code> file where we&rsquo;ll add utility functions as we find needs for them.</p>


        <h2>Create Model Classes</h2>

        <p>We are building an application for organizing to-dos. For each individual thing we need to do, we&rsquo;ll create a model object representing that individual to-do. As life moves along, we&rsquo;ll think of more things to do and hopefully we&rsquo;ll actually get some things done. We'll add and delete individual to-do objects from another kind of model object representing a set of to-dos.</p>

        <p>Create a <code>checkit/src/js/models/</code> directory to contain both of our model classes.</p>


        <h3>The <code>checkit.TodoModel</code> Class</h3>

        <p>Let&rsquo;s start by designing a class for an individual to-do. The two fundamental questions we&rsquo;ll ask a to-do model are:</p>

        <ol>
            <li>What needs doing?</li>
            <li>Has it already been done?</li>
        </ol>

        <p>We&rsquo;ll use the <code>maria.Model</code> class as the parent class for our <code>checkit.Todo</code> class.</p>

<pre><code>maria.Model.subclass(checkit, 'TodoModel', {
    properties: {
        _content: '',
        _isDone: false,
        getContent: function() {
            return this._content;
        },
        setContent: function(content) {
            content = checkit.trim('' + content);
            if (this._content !== content) {
                this._content = content;
                this.dispatchEvent({type: 'change'});
            }
        },
        isDone: function() {
            return this._isDone;
        },
        setDone: function(isDone) {
            isDone = !!isDone;
            if (this._isDone !== isDone) {
                this._isDone = isDone;
                this.dispatchEvent({type: 'change'});
            }
        },
        toggleDone: function() {
            this.setDone(!this.isDone());
        }
    }
});</code></pre>

        <p>The <code>checkit.trim</code> function is an example of a utility function that we&rsquo;ll add to our <code>checkit/src/js/util.js</code> file.</p>

<pre><code>checkit.trim = function(str) {
    return str.replace(/^\s+|\s+$/g, '');
};</code></pre>

        <p>To find out more about the this <code>checkit.TodoModel</code> class, let&rsquo;s get our hands dirty and experiment in a browser console like Firebug. Create an HTML document called <code>checkit/src/index.html</code> that loads both the libraries and our application code.</p>

<pre><code>&lt;!DOCTYPE html>
&lt;html>
&lt;head>
    &lt;title>checkit&lt;/title>

&lt;/head>
&lt;body>

    &lt;script src="../lib/maria/maria.js">&lt;/script>
    &lt;script src="../lib/aristocrat/aristocrat.js">&lt;/script>

    &lt;script src="js/namespace.js">&lt;/script>
    &lt;script src="js/util.js">&lt;/script>
    &lt;script src="js/models/TodoModel.js">&lt;/script>

&lt;/body>
&lt;/html></code></pre>

        <p>With the above page loaded in the browser, we can interactively explore in the console.</p>

        <p>Create a new to-do and check its default content and done values.</p>

<pre><code>> var todoModel = new checkit.TodoModel();
undefined
> todoModel.getContent();
""
> todoModel.isDone();
false</code></pre>

        <p>Let&rsquo;s make the to-do more motivating to do.</p>

<pre><code>> todoModel.setContent('test drive Ferrari');
undefined
> todoModel.getContent();
"test drive Ferrari"
</code></pre>

        <p>Looking good so far but those are just getters and setters. We haven&rsquo;t seen any MVC magic yet. The observer pattern is the first bit of MVC magic we&rsquo;ll explore.</p>

        <p>In most MVC applications, a model object communicates with one or more view objects via the observer pattern. It is a very loose coupling between a model and the views as the model object doesn&rsquo;t  know or even care about what the view objects are doing. When a particular event type happens on the model, the model notifies all the views who&rsquo;ve added themselves as observers of that event type on that view. This gives the views an opportunity to react to the model&rsquo;s event. Typically a view object wants to keep its visual representation up-to-date to match the model object&rsquo;s current state.</p>

        <p>Let&rsquo;s see the observer pattern relationship between a to-do model object and fake view object.</p>
    
        <p>We create a fake view object and add it as an observer of the to-do model object.</p>

<pre><code>> var view = {update: function(evt) {console.log('The model changed!')}};
undefined
> maria.addEventListener(todoModel, 'change', view, 'update');
undefined</code></pre>

        <p>Now a change to the model object&rsquo;s done value will cause the model to call the view&rsquo;s <code>update</code> method.<p>

<pre><code>> todoModel.setDone(true);
"The model changed!"
undefined</code></pre>

        <p>If we remove the observer from the model and change the done value again, we see the view is no longer notified.</p>

<pre><code>> maria.removeEventListener(todoModel, 'change', view, 'update);
undefined
todoModel.setDone(false);
undefined
</code></pre>

        <p>Try adding multiple fake views as observers of one model. Try calling <code>todoModel.setDone(true)</code> multiple times consecutively. What information does the <code>evt</code> object contain that is passed to the observer's method? Experiment. Explore.</p>

        <p>If you are a devout test-driven developer, you&rsquo;re surely disappointed that code&rsquo;s been written but tests haven&rsquo;t. Forgive us. We have sinned. Now is a good time to repent and make amends. Add your test library in a subdirectory of <code>checkit/lib/</code> if necessary, your tests in a <code>checkit/tst/</code> or <code>checkit/spec/</code> directory, and float your boat. By the way, I recommend you check out the great <a href="http://busterjs.org/">Buster</a> automated testing tools which are used for testing the Maria source code.</p>


        <h2>The checkit.TodosModel Class</h2>

        <p>There&rsquo;s never enough time in life for all things we want to do. We need to manage a set of to-dos. Let&rsquo;s create a class who&rsquo;s objects can do just that.</p>

        <p>An object of the <code>maria.SetModel</code> class is an unordered set that can hold any number of other model objects. Observers of a set model are notified when those other model objects are added or deleted from the set. We can subclass <code>maria.SetModel</code> as a starting point for our <code>checkit.TodosModel</code> class in a file <code>checkit/src/js/models/TodosModel.js</code>.</p>

<pre><code>maria.SetModel.subclass(checkit, 'TodosModel', {
    properties: {
        getDone: function() {
            return this.filter(function(todo) {
                return todo.isDone();
            });
        },
        isAllDone: function() {
            return (this.length > 0) &amp;&amp;
                   (this.getDone().length === this.length);
        },
        isAllUndone: function() {
            return this.getDone().length &lt; 1;
        },
        markAllDone: function() {
            this.forEach(function(todo) {
                todo.setDone(true);
            });
        },
        markAllUndone: function() {
            this.forEach(function(todo) {
                todo.setDone(false);
            });
        },
        deleteDone: function() {
            this['delete'].apply(this, this.getDone());
        }
    }
});</code></pre>

        <p>Add this file to the <code>checkit/src/index.html</code> page, reload the browser, and explore some more.</p>

        <p>Create a set for to-dos and add an observer who will log to-dos added to an the set.</p>

<pre><code>> var todosModel = new checkit.TodosModel();
undefined
> var view = {update: function(evt) {console.log(evt.addedTargets.map(function(todo) {return todo.getContent();}));}};
undefined
> maria.addEventListener(todosModel, 'change', view, 'update');
undefined</code></pre>

        <p>Now add a to-do to the set.</p>

<pre><code>> var todoModel = new checkit.TodoModel();
undefined
> todoModel.setContent('dinner date with Maria');
undefined
> todosModel.add(todoModel);
["dinner date with Maria"]
undefined</code></pre>

        <p>There are a few things we should probably do before our date. Let&rsquo;s add them.</p>

<pre><code>> var flowers = new checkit.TodoModel();
undefined
> flowers.setContent('buy flowers');
undefined
> var shower = new checkit.TodoModel();
undefined
> shower.setContent('take a shower');
undefined
> todosModel.add(flowers, shower);
["buy flowers", "take a shower"]
undefined</code></pre>

        <p>We see that adding multiple to-do models to the set with one call to the set&rsquo;s <code>add</code> method means only one event is fired. This can be good for efficiency by reducing the number of updates views have to do.</p>

        <p>When we go out and buy the flowers, we&rsquo;ll mark the corresponding to-do as done. Let&rsquo; change the view&rsquo;s <code>update</code> method so we can examine what happens to the set when the to-do is marked as done. Remember the view is observing the set.</p>

<pre><code>> view.update = function(evt) {console.log(evt.target.constructor === checkit.TodoModel, evt.currentTarget.constructor === checkit.TodosModel);};
function()
> flowers.setDone(true);
true true
undefined
</code></pre>

        <p>What&rsquo;s important to note above is that the <code>evt.target</code> is the flowers to-do but that the event bubbles up to the containing to-dos set which is the <code>evt.currentTarget</code>. This bubbling makes it possible for views to observe all the activity on an entire set of models without our application code having to manually add and remove the view as an observer for each model in the set.</p>

        <p>We might want to clean up our to-dos set by deleting all the to-do models that are done.</p>

<pre><code>> todosModel.deleteDone();
undefined
> todosModel.length;
2
</code></pre>

        <p>You may have noticed that the implementation of the <code>deleteDone</code> method contains <code>this['delete']</code> syntax. Since <code>delete</code> is a JavaScript keyword, older browsers did not allow us to write the simpler <code>this.delete</code> syntax. If you are only need to support newer browsers, you can use the simpler version.</p>

        <p>Our model layer is complete.</p>

        <p>Well. The tests. Yes, yes. Please write them.</p>

    </div><!-- wrapper -->

</body>
</html>
